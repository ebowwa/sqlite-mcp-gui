<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQLite MCP GUI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 30px;
        }

        h1 {
            color: #00d9ff;
            font-size: 2em;
        }

        .subtitle {
            color: #888;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .connection-panel {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="text"] {
            flex: 1;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f3460;
            color: #eee;
            font-size: 14px;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #00d9ff;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #00d9ff;
            color: #1a1a2e;
        }

        .btn-primary:hover {
            background: #00b8dd;
        }

        .btn-success {
            background: #00ff88;
            color: #1a1a2e;
        }

        .btn-success:hover {
            background: #00dd77;
        }

        .btn-secondary {
            background: #535c68;
            color: #eee;
        }

        .btn-secondary:hover {
            background: #636e72;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 13px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
        }

        .sidebar {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
            height: fit-content;
        }

        .sidebar h3 {
            color: #00d9ff;
            margin-bottom: 15px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .table-list {
            list-style: none;
        }

        .table-item {
            padding: 10px;
            margin: 5px 0;
            background: #0f3460;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .table-item:hover {
            background: #1a4a7a;
        }

        .table-item.active {
            background: #00d9ff;
            color: #1a1a2e;
        }

        .query-panel {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
        }

        .query-input {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f3460;
            color: #eee;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            resize: vertical;
        }

        .query-input:focus {
            outline: none;
            border-color: #00d9ff;
        }

        .query-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .results-panel {
            background: #16213e;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .results-info {
            color: #888;
            font-size: 0.9em;
        }

        .view-toggles {
            display: flex;
            gap: 10px;
        }

        .view-toggle {
            padding: 6px 12px;
            background: #0f3460;
            border: 1px solid #333;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .view-toggle:hover {
            background: #1a4a7a;
            color: #eee;
        }

        .view-toggle.active {
            background: #00d9ff;
            border-color: #00d9ff;
            color: #1a1a2e;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        th {
            background: #0f3460;
            color: #00d9ff;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background: #1a4a7a;
        }

        .error {
            background: #3a1a1a;
            color: #ff6b6b;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #ff6b6b;
        }

        .success {
            background: #1a3a1a;
            color: #00ff88;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #00ff88;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #888;
        }

        .status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status.connected {
            background: #00ff88;
        }

        .status.disconnected {
            background: #ff6b6b;
        }

        /* Chart Controls */
        .chart-controls {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .chart-controls.visible {
            display: block;
        }

        .chart-controls-row {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .chart-controls-row:last-child {
            margin-bottom: 0;
        }

        .chart-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .chart-control-group label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select.chart-select {
            padding: 8px 12px;
            background: #1a1a2e;
            border: 1px solid #333;
            border-radius: 4px;
            color: #eee;
            font-size: 13px;
            min-width: 150px;
            cursor: pointer;
        }

        select.chart-select:focus {
            outline: none;
            border-color: #00d9ff;
        }

        .chart-suggestion {
            padding: 8px 12px;
            background: #1a3a1a;
            border: 1px solid #00ff88;
            border-radius: 4px;
            color: #00ff88;
            font-size: 12px;
            display: none;
        }

        .chart-suggestion.visible {
            display: inline-block;
        }

        /* Chart Container */
        .chart-container {
            position: relative;
            background: #0f3460;
            border-radius: 8px;
            padding: 20px;
            display: none;
        }

        .chart-container.visible {
            display: block;
        }

        .chart-canvas-wrapper {
            position: relative;
            width: 100%;
            height: 500px;
        }

        canvas.chart-canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        /* Chart Tooltip */
        .chart-tooltip {
            position: absolute;
            background: rgba(22, 33, 62, 0.95);
            border: 1px solid #00d9ff;
            border-radius: 6px;
            padding: 10px 15px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            font-size: 13px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 300px;
        }

        .chart-tooltip.visible {
            display: block;
        }

        .chart-tooltip-title {
            color: #00d9ff;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .chart-tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 3px 0;
        }

        .chart-tooltip-label {
            color: #888;
        }

        .chart-tooltip-value {
            color: #eee;
            font-weight: 600;
        }

        /* Chart Type Buttons */
        .chart-type-buttons {
            display: flex;
            gap: 5px;
        }

        .chart-type-btn {
            padding: 8px 12px;
            background: #1a1a2e;
            border: 1px solid #333;
            border-radius: 4px;
            color: #888;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .chart-type-btn:hover {
            background: #1a4a7a;
            color: #eee;
        }

        .chart-type-btn.active {
            background: #00d9ff;
            border-color: #00d9ff;
            color: #1a1a2e;
        }

        .chart-type-btn.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Login Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .login-modal {
            background: #16213e;
            border-radius: 12px;
            padding: 40px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .login-modal h2 {
            color: #00d9ff;
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.8em;
        }

        .login-form .form-group {
            margin-bottom: 20px;
        }

        .login-form label {
            display: block;
            margin-bottom: 8px;
            color: #888;
            font-size: 0.9em;
        }

        .login-form input[type="text"],
        .login-form input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f3460;
            color: #eee;
            font-size: 14px;
            box-sizing: border-box;
        }

        .login-form input:focus {
            outline: none;
            border-color: #00d9ff;
        }

        .login-form .btn-login {
            width: 100%;
            padding: 14px;
            background: #00d9ff;
            color: #1a1a2e;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .login-form .btn-login:hover {
            background: #00b8dd;
        }

        /* User Info Bar */
        .user-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: #0f3460;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #00d9ff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a2e;
            font-weight: bold;
            font-size: 16px;
        }

        .user-details {
            display: flex;
            flex-direction: column;
        }

        .user-name {
            font-weight: 600;
            color: #eee;
        }

        .user-role {
            font-size: 0.85em;
            color: #888;
        }

        .btn-logout {
            padding: 8px 16px;
            background: transparent;
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-logout:hover {
            background: #ff6b6b;
            color: #1a1a2e;
        }

        input[type="password"] {
            flex: 1;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0f3460;
            color: #eee;
            font-size: 14px;
        }

        input[type="password"]:focus {
            outline: none;
            border-color: #00d9ff;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .chart-controls-row {
                flex-direction: column;
                align-items: stretch;
            }

            .chart-canvas-wrapper {
                height: 350px;
            }
        }
    </style>
</head>
<body>
    <!-- Login Modal -->
    <div class="modal-overlay" id="loginModal">
        <div class="login-modal">
            <h2>Login</h2>
            <form class="login-form" onsubmit="handleLogin(event)">
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" name="username" required autofocus>
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" required>
                </div>
                <button type="submit" class="btn-login">Login</button>
            </form>
            <div id="loginError" style="margin-top: 15px; color: #ff6b6b; text-align: center; display: none;"></div>
        </div>
    </div>

    <div class="container" id="mainContainer" style="display: none;">
        <header>
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h1>SQLite MCP GUI</h1>
                    <p class="subtitle">A web interface for SQLite databases using MCP protocol</p>
                </div>
            </div>
        </header>

        <!-- User Info Bar -->
        <div class="user-bar" id="userBar">
            <div class="user-info">
                <div class="user-avatar" id="userAvatar">A</div>
                <div class="user-details">
                    <span class="user-name" id="userName">Admin User</span>
                    <span class="user-role" id="userRole">Administrator</span>
                </div>
            </div>
            <button class="btn-logout" onclick="handleLogout()">Logout</button>
        </div>

        <div class="connection-panel">
            <div class="input-group">
                <input type="text" id="dbPath" placeholder="/path/to/database.db" value="./test.db">
                <button class="btn-primary" onclick="connect()">Connect</button>
            </div>
            <p style="margin-top: 10px; color: #888; font-size: 0.9em;">
                <span class="status disconnected" id="status"></span>
                <span id="statusText">Disconnected</span>
            </p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>Tables</h3>
                <ul class="table-list" id="tableList">
                    <li class="empty-state" style="padding: 20px 0; font-size: 0.9em;">
                        Connect to a database to view tables
                    </li>
                </ul>
            </div>

            <div>
                <div class="query-panel">
                    <textarea class="query-input" id="queryInput" placeholder="Enter SQL query...

Examples:
SELECT * FROM users LIMIT 10
SELECT name, sqlite_master.* FROM sqlite_master

Chart Examples (add /* chart:type */ comment):
/* chart:bar */ SELECT category, COUNT(*) as count FROM sales GROUP BY category
/* chart:line */ SELECT date, revenue FROM sales ORDER BY date
/* chart:pie */ SELECT status, COUNT(*) as count FROM orders GROUP BY status
/* chart:scatter */ SELECT x_coord, y_coord FROM coordinates
/* chart:histogram */ SELECT price FROM products"></textarea>
                    <div class="query-actions">
                        <button class="btn-success" onclick="executeQuery()">Execute Query</button>
                        <button class="btn-primary" onclick="loadTables()">Refresh Tables</button>
                    </div>
                </div>

                <div class="results-panel" id="resultsPanel" style="display: none;">
                    <div class="results-header">
                        <h3>Results</h3>
                        <div class="view-toggles" id="viewToggles" style="display: none;">
                            <button class="view-toggle active" data-view="table" onclick="switchView('table')">Table</button>
                            <button class="view-toggle" data-view="chart" onclick="switchView('chart')">Chart</button>
                        </div>
                        <span class="results-info" id="resultsInfo"></span>
                    </div>

                    <!-- Chart Controls -->
                    <div class="chart-controls" id="chartControls">
                        <div class="chart-controls-row">
                            <div class="chart-type-buttons">
                                <button class="chart-type-btn" data-type="bar" onclick="setChartType('bar')">Bar</button>
                                <button class="chart-type-btn" data-type="line" onclick="setChartType('line')">Line</button>
                                <button class="chart-type-btn" data-type="pie" onclick="setChartType('pie')">Pie</button>
                                <button class="chart-type-btn" data-type="scatter" onclick="setChartType('scatter')">Scatter</button>
                                <button class="chart-type-btn" data-type="histogram" onclick="setChartType('histogram')">Histogram</button>
                            </div>
                            <div class="chart-suggestion" id="chartSuggestion"></div>
                        </div>
                        <div class="chart-controls-row">
                            <div class="chart-control-group">
                                <label>X-Axis / Labels</label>
                                <select class="chart-select" id="xAxisSelect" onchange="updateChart()"></select>
                            </div>
                            <div class="chart-control-group">
                                <label>Y-Axis / Values</label>
                                <select class="chart-select" id="yAxisSelect" onchange="updateChart()"></select>
                            </div>
                            <div class="chart-control-group">
                                <label>Group By (Optional)</label>
                                <select class="chart-select" id="groupSelect" onchange="updateChart()">
                                    <option value="">None</option>
                                </select>
                            </div>
                            <div style="margin-left: auto;">
                                <button class="btn-secondary btn-small" onclick="exportChart()">Export PNG</button>
                            </div>
                        </div>
                    </div>

                    <!-- Chart Container -->
                    <div class="chart-container" id="chartContainer">
                        <div class="chart-canvas-wrapper">
                            <canvas class="chart-canvas" id="chartCanvas"></canvas>
                            <div class="chart-tooltip" id="chartTooltip"></div>
                        </div>
                        <div class="chart-legend" id="chartLegend"></div>
                    </div>

                    <!-- Results Content -->
                    <div id="resultsContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentDbPath = '';
        let connected = false;
        let authToken = null;
        let currentUser = null;

        // Visualization state
        let chartData = null;
        let chartType = 'bar';
        let currentView = 'table';
        let chartInstance = null;
        let zoomState = { offsetX: 0, offsetY: 0, scale: 1 };
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };

        // Color palette for charts
        const CHART_COLORS = [
            '#00d9ff', '#00ff88', '#ff6b6b', '#ffd93d', '#6bcb77',
            '#4d96ff', '#ff6eb4', '#a29bfe', '#fd79a8', '#00b894',
            '#e17055', '#0984e3', '#6c5ce7', '#fdcb6e', '#e84393'
        ];

        // Chart rendering engine
        class ChartRenderer {
            constructor(canvas, tooltip) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.tooltip = tooltip;
                this.data = null;
                this.type = 'bar';
                this.colors = CHART_COLORS;
                this.padding = { top: 40, right: 40, bottom: 60, left: 70 };
                this.hoveredPoint = null;
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseleave', () => this.hideTooltip());
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
                this.canvas.addEventListener('mouseleave', () => { isDragging = false; });
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                this.render();
            }

            setData(data, type) {
                this.data = this.processData(data, type);
                this.type = type;
                this.render();
                this.updateLegend();
            }

            processData(data, type) {
                if (!data || !data.rows || data.rows.length === 0) return null;

                const rows = data.rows;
                const xCol = data.xAxis;
                const yCol = data.yAxis;
                const groupCol = data.groupBy;

                let processed = { labels: [], datasets: [], maxValue: 0 };

                if (type === 'pie') {
                    // Pie chart: aggregate values
                    const groups = {};
                    rows.forEach(row => {
                        const key = row[xCol] || 'NULL';
                        const val = parseFloat(row[yCol]) || 0;
                        groups[key] = (groups[key] || 0) + val;
                    });
                    processed.labels = Object.keys(groups);
                    processed.datasets = [{
                        data: Object.values(groups),
                        colors: this.colors.slice(0, Object.keys(groups).length)
                    }];
                } else if (type === 'histogram') {
                    // Histogram: bin the data
                    const values = rows.map(row => parseFloat(row[yCol])).filter(v => !isNaN(v));
                    const binCount = Math.min(20, Math.ceil(Math.sqrt(values.length)));
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const binSize = (max - min) / binCount || 1;

                    const bins = new Array(binCount).fill(0);
                    const binLabels = [];
                    for (let i = 0; i < binCount; i++) {
                        const binStart = min + i * binSize;
                        const binEnd = min + (i + 1) * binSize;
                        binLabels.push(`${binStart.toFixed(2)} - ${binEnd.toFixed(2)}`);
                    }

                    values.forEach(v => {
                        const binIndex = Math.min(Math.floor((v - min) / binSize), binCount - 1);
                        bins[binIndex]++;
                    });

                    processed.labels = binLabels;
                    processed.datasets = [{
                        data: bins,
                        colors: this.colors.slice(0, binCount)
                    }];
                } else if (type === 'scatter') {
                    // Scatter plot: x and y coordinates
                    processed.points = rows.map(row => ({
                        x: parseFloat(row[xCol]) || 0,
                        y: parseFloat(row[yCol]) || 0,
                        original: row
                    }));
                    processed.maxX = Math.max(...processed.points.map(p => p.x), 1);
                    processed.maxY = Math.max(...processed.points.map(p => p.y), 1);
                } else {
                    // Bar and Line charts
                    if (groupCol) {
                        // Grouped data
                        const groups = {};
                        rows.forEach(row => {
                            const group = row[groupCol] || 'NULL';
                            if (!groups[group]) groups[group] = [];
                            groups[group].push({ x: row[xCol], y: parseFloat(row[yCol]) || 0, original: row });
                        });

                        const allLabels = [...new Set(rows.map(r => r[xCol]))];
                        processed.labels = allLabels;

                        Object.keys(groups).forEach((group, i) => {
                            const groupData = allLabels.map(label => {
                                const item = groups[group].find(g => g.x === label);
                                return item ? item.y : 0;
                            });
                            processed.datasets.push({
                                label: group,
                                data: groupData,
                                color: this.colors[i % this.colors.length]
                            });
                        });
                    } else {
                        // Simple data
                        processed.labels = rows.map(row => row[xCol]);
                        const values = rows.map(row => parseFloat(row[yCol]) || 0);
                        processed.datasets = [{
                            data: values,
                            color: this.colors[0]
                        }];
                    }

                    // Calculate max value for y-axis
                    processed.maxValue = Math.max(...processed.datasets.flatMap(d => d.data), 1);
                }

                return processed;
            }

            render() {
                if (!this.data) return;

                const rect = this.canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                this.ctx.clearRect(0, 0, width, height);
                this.ctx.save();

                // Apply zoom and pan
                this.ctx.translate(zoomState.offsetX, zoomState.offsetY);
                this.ctx.scale(zoomState.scale, zoomState.scale);

                const chartWidth = width - this.padding.left - this.padding.right;
                const chartHeight = height - this.padding.top - this.padding.bottom;

                switch (this.type) {
                    case 'bar':
                        this.renderBarChart(chartWidth, chartHeight);
                        break;
                    case 'line':
                        this.renderLineChart(chartWidth, chartHeight);
                        break;
                    case 'pie':
                        this.renderPieChart(width, height);
                        break;
                    case 'scatter':
                        this.renderScatterChart(chartWidth, chartHeight);
                        break;
                    case 'histogram':
                        this.renderBarChart(chartWidth, chartHeight);
                        break;
                }

                this.ctx.restore();
            }

            renderBarChart(width, height) {
                const { labels, datasets, maxValue } = this.data;
                const barWidth = (width / labels.length) * 0.8;
                const groupWidth = barWidth / datasets.length;
                const maxValueScaled = maxValue * 1.1;

                // Draw axes
                this.drawAxes(width, height, labels, maxValueScaled);

                // Draw bars
                datasets.forEach((dataset, datasetIndex) => {
                    dataset.data.forEach((value, i) => {
                        const barHeight = (value / maxValueScaled) * height;
                        const x = this.padding.left + (i * (width / labels.length)) +
                                  (width / labels.length - barWidth) / 2 +
                                  (datasetIndex * groupWidth);
                        const y = this.padding.top + height - barHeight;

                        this.ctx.fillStyle = dataset.color || dataset.colors[i];
                        this.ctx.fillRect(x, y, groupWidth - 2, barHeight);

                        // Store bar position for tooltip
                        if (!dataset.positions) dataset.positions = [];
                        dataset.positions[i] = { x, y, width: groupWidth - 2, height: barHeight, value, label: labels[i] };
                    });
                });
            }

            renderLineChart(width, height) {
                const { labels, datasets, maxValue } = this.data;
                const maxValueScaled = maxValue * 1.1;
                const pointSpacing = width / (labels.length - 1 || 1);

                // Draw axes
                this.drawAxes(width, height, labels, maxValueScaled);

                // Draw lines
                datasets.forEach(dataset => {
                    if (dataset.data.length === 0) return;

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = dataset.color;
                    this.ctx.lineWidth = 3;

                    dataset.data.forEach((value, i) => {
                        const x = this.padding.left + (i * pointSpacing);
                        const y = this.padding.top + height - ((value / maxValueScaled) * height);

                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }

                        // Store point position for tooltip
                        if (!dataset.positions) dataset.positions = [];
                        dataset.positions[i] = { x, y, value, label: labels[i] };
                    });

                    this.ctx.stroke();

                    // Draw points
                    dataset.data.forEach((value, i) => {
                        const x = this.padding.left + (i * pointSpacing);
                        const y = this.padding.top + height - ((value / maxValueScaled) * height);

                        this.ctx.beginPath();
                        this.ctx.fillStyle = dataset.color;
                        this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                        this.ctx.fill();

                        this.ctx.beginPath();
                        this.ctx.fillStyle = '#fff';
                        this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                });
            }

            renderPieChart(width, height) {
                const { labels, datasets } = this.data;
                const data = datasets[0].data;
                const colors = datasets[0].colors;
                const total = data.reduce((sum, val) => sum + val, 0);

                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) / 2 - 40;

                let startAngle = -Math.PI / 2;

                data.forEach((value, i) => {
                    const sliceAngle = (value / total) * Math.PI * 2;
                    const endAngle = startAngle + sliceAngle;

                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    this.ctx.closePath();

                    this.ctx.fillStyle = colors[i];
                    this.ctx.fill();

                    // Store slice position for tooltip
                    if (!datasets[0].positions) datasets[0].positions = [];
                    datasets[0].positions[i] = {
                        centerX, centerY, radius,
                        startAngle, endAngle,
                        value, label: labels[i],
                        percentage: ((value / total) * 100).toFixed(1)
                    };

                    startAngle = endAngle;
                });

                // Draw center circle for donut effect
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, radius * 0.5, 0, Math.PI * 2);
                this.ctx.fillStyle = '#0f3460';
                this.ctx.fill();
            }

            renderScatterChart(width, height) {
                const { points, maxX, maxY } = this.data;
                const padding = 20;

                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;

                // Draw grid
                for (let i = 0; i <= 5; i++) {
                    const y = this.padding.top + (height / 5) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding.left, y);
                    this.ctx.lineTo(this.padding.left + width, y);
                    this.ctx.stroke();
                }

                for (let i = 0; i <= 5; i++) {
                    const x = this.padding.left + (width / 5) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, this.padding.top);
                    this.ctx.lineTo(x, this.padding.top + height);
                    this.ctx.stroke();
                }

                // Draw axes
                this.ctx.strokeStyle = '#888';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding.left, this.padding.top);
                this.ctx.lineTo(this.padding.left, this.padding.top + height);
                this.ctx.lineTo(this.padding.left + width, this.padding.top + height);
                this.ctx.stroke();

                // Draw axis labels
                this.ctx.fillStyle = '#888';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';

                for (let i = 0; i <= 5; i++) {
                    const y = this.padding.top + height - (height / 5) * i;
                    const val = ((maxY / 5) * i).toFixed(1);
                    this.ctx.fillText(val, this.padding.left - 10, y + 4);
                }

                for (let i = 0; i <= 5; i++) {
                    const x = this.padding.left + (width / 5) * i;
                    const val = ((maxX / 5) * i).toFixed(1);
                    this.ctx.fillText(val, x, this.padding.top + height + 20);
                }

                // Draw points
                points.forEach((point, i) => {
                    const x = this.padding.left + ((point.x / maxX) * width);
                    const y = this.padding.top + height - ((point.y / maxY) * height);

                    this.ctx.beginPath();
                    this.ctx.fillStyle = this.colors[0];
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1;

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                    this.ctx.stroke();

                    if (!points.positions) points.positions = [];
                    points.positions = points.positions || [];
                    points.positions[i] = { x, y, point };
                });
            }

            drawAxes(width, height, labels, maxValue) {
                this.ctx.strokeStyle = '#888';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(this.padding.left, this.padding.top);
                this.ctx.lineTo(this.padding.left, this.padding.top + height);
                this.ctx.lineTo(this.padding.left + width, this.padding.top + height);
                this.ctx.stroke();

                // Draw grid and y-axis labels
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 1;
                this.ctx.fillStyle = '#888';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'right';

                for (let i = 0; i <= 5; i++) {
                    const y = this.padding.top + height - (height / 5) * i;
                    const val = ((maxValue / 5) * i).toFixed(1);

                    this.ctx.beginPath();
                    this.ctx.moveTo(this.padding.left, y);
                    this.ctx.lineTo(this.padding.left + width, y);
                    this.ctx.stroke();

                    this.ctx.fillText(val, this.padding.left - 10, y + 4);
                }

                // Draw x-axis labels
                this.ctx.textAlign = 'center';
                const labelStep = Math.ceil(labels.length / 10);
                labels.forEach((label, i) => {
                    if (i % labelStep !== 0) return;
                    const x = this.padding.left + (i * (width / labels.length)) + (width / labels.length) / 2;
                    const y = this.padding.top + height + 20;

                    const displayLabel = String(label).length > 15
                        ? String(label).substring(0, 12) + '...'
                        : label;
                    this.ctx.fillText(displayLabel, x, y);
                });
            }

            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - zoomState.offsetX;
                const y = e.clientY - rect.top - zoomState.offsetY;

                this.hoveredPoint = null;

                if (this.type === 'scatter' && this.data.points) {
                    this.data.points.positions?.forEach((pos, i) => {
                        const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                        if (dist < 10) {
                            this.hoveredPoint = { type: 'scatter', data: pos.point, x: pos.x, y: pos.y };
                        }
                    });
                } else if (this.data.datasets) {
                    this.data.datasets.forEach(dataset => {
                        dataset.positions?.forEach((pos, i) => {
                            if (this.type === 'pie') {
                                const dx = x - pos.centerX;
                                const dy = y - pos.centerY;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < pos.radius) {
                                    let angle = Math.atan2(dy, dx);
                                    if (angle < -Math.PI / 2) angle += Math.PI * 2;
                                    if (angle >= pos.startAngle && angle <= pos.endAngle) {
                                        this.hoveredPoint = { type: 'pie', data: pos, x, y };
                                    }
                                }
                            } else {
                                if (x >= pos.x && x <= pos.x + (pos.width || 10) &&
                                    y >= pos.y && y <= pos.y + (pos.height || 10)) {
                                    this.hoveredPoint = { type: 'bar/line', data: pos, dataset: dataset.label };
                                }
                            }
                        });
                    });
                }

                if (this.hoveredPoint) {
                    this.showTooltip(this.hoveredPoint, e.clientX, e.clientY);
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.hideTooltip();
                    this.canvas.style.cursor = isDragging ? 'grabbing' : 'grab';
                }
            }

            handleClick(e) {
                if (this.hoveredPoint && this.hoveredPoint.data.original) {
                    // Drill down: show original row data
                    const row = this.hoveredPoint.data.original;
                    let rowInfo = Object.entries(row)
                        .map(([k, v]) => `${k}: ${v}`)
                        .join('\n');
                    alert(`Row Data:\n${rowInfo}`);
                }
            }

            handleWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomState.scale = Math.max(0.5, Math.min(3, zoomState.scale * delta));
                this.render();
            }

            handleMouseDown(e) {
                isDragging = true;
                dragStart = { x: e.clientX - zoomState.offsetX, y: e.clientY - zoomState.offsetY };
                this.canvas.style.cursor = 'grabbing';
            }

            handleMouseUp(e) {
                if (isDragging) {
                    zoomState.offsetX = e.clientX - dragStart.x;
                    zoomState.offsetY = e.clientY - dragStart.y;
                    isDragging = false;
                    this.render();
                }
            }

            showTooltip(point, mouseX, mouseY) {
                let html = '<div class="chart-tooltip-title">';
                let content = '';

                if (point.type === 'scatter') {
                    html += 'Data Point';
                    content = `
                        <div class="chart-tooltip-row"><span class="chart-tooltip-label">X:</span><span class="chart-tooltip-value">${point.data.x.toFixed(2)}</span></div>
                        <div class="chart-tooltip-row"><span class="chart-tooltip-label">Y:</span><span class="chart-tooltip-value">${point.data.y.toFixed(2)}</span></div>
                    `;
                } else if (point.type === 'pie') {
                    html += point.data.label;
                    content = `
                        <div class="chart-tooltip-row"><span class="chart-tooltip-label">Value:</span><span class="chart-tooltip-value">${point.data.value.toFixed(2)}</span></div>
                        <div class="chart-tooltip-row"><span class="chart-tooltip-label">Percentage:</span><span class="chart-tooltip-value">${point.data.percentage}%</span></div>
                    `;
                } else {
                    html += point.dataset || point.data.label;
                    content = `
                        <div class="chart-tooltip-row"><span class="chart-tooltip-label">${point.data.label}:</span><span class="chart-tooltip-value">${point.data.value.toFixed(2)}</span></div>
                    `;
                }

                this.tooltip.innerHTML = html + '</div>' + content;

                const rect = this.canvas.getBoundingClientRect();
                const x = mouseX - rect.left + 15;
                const y = mouseY - rect.top + 15;

                this.tooltip.style.left = x + 'px';
                this.tooltip.style.top = y + 'px';
                this.tooltip.classList.add('visible');
            }

            hideTooltip() {
                this.tooltip.classList.remove('visible');
            }

            updateLegend() {
                const legend = document.getElementById('chartLegend');
                if (!this.data || this.type === 'scatter' || this.type === 'histogram') {
                    legend.innerHTML = '';
                    return;
                }

                if (this.type === 'pie') {
                    legend.innerHTML = this.data.labels.map((label, i) => `
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${this.data.datasets[0].colors[i]}"></div>
                            <span>${label}</span>
                        </div>
                    `).join('');
                } else {
                    legend.innerHTML = this.data.datasets.map(ds => `
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${ds.color}"></div>
                            <span>${ds.label || 'Value'}</span>
                        </div>
                    `).join('');
                }
            }
        }

        // Initialize chart renderer
        let chartRenderer = null;

        // Check authentication status on load
        async function checkAuth() {
            try {
                const response = await fetch('/auth/config');
                const config = await response.json();

                if (!config.enabled) {
                    showMainUI();
                    return;
                }

                const meResponse = await fetch('/auth/me');
                const meData = await meResponse.json();

                if (meData.authenticated) {
                    currentUser = meData.user;
                    showMainUI();
                } else {
                    showLoginModal();
                }
            } catch (error) {
                console.error('Auth check failed:', error);
                showMainUI();
            }
        }

        function showLoginModal() {
            document.getElementById('loginModal').classList.add('active');
            document.getElementById('mainContainer').style.display = 'none';
        }

        function showMainUI() {
            document.getElementById('loginModal').classList.remove('active');
            document.getElementById('mainContainer').style.display = 'block';

            if (currentUser) {
                document.getElementById('userName').textContent = currentUser.username;
                document.getElementById('userRole').textContent = formatRole(currentUser.role);
                document.getElementById('userAvatar').textContent = currentUser.username.charAt(0).toUpperCase();
            } else {
                document.getElementById('userBar').style.display = 'none';
            }

            // Initialize chart renderer
            const canvas = document.getElementById('chartCanvas');
            const tooltip = document.getElementById('chartTooltip');
            chartRenderer = new ChartRenderer(canvas, tooltip);
        }

        function formatRole(role) {
            const roleMap = {
                'admin': 'Administrator',
                'read-write': 'Read & Write Access',
                'read-only': 'Read Only Access'
            };
            return roleMap[role] || role;
        }

        async function handleLogin(event) {
            event.preventDefault();

            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const errorDiv = document.getElementById('loginError');

            try {
                const response = await fetch('/auth/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });

                const data = await response.json();

                if (data.success) {
                    currentUser = data.user;
                    authToken = data.token;
                    showMainUI();
                    errorDiv.style.display = 'none';
                } else {
                    errorDiv.textContent = data.message || 'Login failed';
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                errorDiv.textContent = 'Login failed: ' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        async function handleLogout() {
            try {
                await fetch('/auth/logout', { method: 'POST' });
                authToken = null;
                currentUser = null;
                showLoginModal();
            } catch (error) {
                console.error('Logout failed:', error);
            }
        }

        async function authenticatedFetch(url, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            return fetch(url, {
                ...options,
                headers
            });
        }

        checkAuth();

        async function connect() {
            const dbPath = document.getElementById('dbPath').value;
            if (!dbPath) {
                showError('Please enter a database path');
                return;
            }

            try {
                const response = await authenticatedFetch('/api/tables', {
                    method: 'POST',
                    body: JSON.stringify({ dbPath })
                });

                const data = await response.json();

                if (data.success) {
                    currentDbPath = dbPath;
                    connected = true;
                    updateStatus(true);
                    displayTables(data.tables);
                    showSuccess(`Connected to ${dbPath}`);
                } else {
                    throw new Error(data.error || 'Connection failed');
                }
            } catch (error) {
                showError(error.message || 'Failed to connect');
                updateStatus(false);
            }
        }

        async function loadTables() {
            if (!connected) {
                showError('Please connect to a database first');
                return;
            }

            try {
                const response = await authenticatedFetch('/api/tables', {
                    method: 'POST',
                    body: JSON.stringify({ dbPath: currentDbPath })
                });

                const data = await response.json();
                if (data.success) {
                    displayTables(data.tables);
                }
            } catch (error) {
                showError(error.message);
            }
        }

        function displayTables(tables) {
            const tableList = document.getElementById('tableList');
            if (tables.length === 0) {
                tableList.innerHTML = '<li class="empty-state" style="padding: 20px 0; font-size: 0.9em;">No tables found</li>';
                return;
            }

            tableList.innerHTML = tables.map(table =>
                `<li class="table-item" onclick="selectTable('${table}')">${table}</li>`
            ).join('');
        }

        async function selectTable(tableName) {
            document.getElementById('queryInput').value = `SELECT * FROM ${tableName} LIMIT 100`;
            document.querySelectorAll('.table-item').forEach(el => el.classList.remove('active'));
            event.target.classList.add('active');
        }

        async function executeQuery() {
            const sql = document.getElementById('queryInput').value.trim();
            if (!sql) {
                showError('Please enter a SQL query');
                return;
            }

            if (!connected) {
                showError('Please connect to a database first');
                return;
            }

            try {
                const response = await authenticatedFetch('/api/query', {
                    method: 'POST',
                    body: JSON.stringify({ dbPath: currentDbPath, sql })
                });

                const data = await response.json();

                if (data.success) {
                    if (data.rows !== undefined) {
                        displayResults(data.rows, data.rowCount, sql);
                    } else {
                        showSuccess(`Query executed successfully. ${data.changes || 0} row(s) affected.`);
                    }
                } else {
                    throw new Error(data.error || 'Query failed');
                }
            } catch (error) {
                showError(error.message);
            }
        }

        function displayResults(rows, rowCount, sql) {
            const resultsPanel = document.getElementById('resultsPanel');
            const resultsContent = document.getElementById('resultsContent');
            const resultsInfo = document.getElementById('resultsInfo');
            const viewToggles = document.getElementById('viewToggles');
            const chartControls = document.getElementById('chartControls');

            resultsPanel.style.display = 'block';
            resultsInfo.textContent = `${rowCount} row(s) returned`;

            if (!Array.isArray(rows) || rows.length === 0) {
                resultsContent.innerHTML = '<div class="empty-state">No results</div>';
                viewToggles.style.display = 'none';
                chartControls.classList.remove('visible');
                return;
            }

            // Store data for charting
            chartData = { rows, rowCount };

            // Parse SQL for chart type hint
            const chartHint = parseChartHint(sql);
            if (chartHint) {
                chartType = chartHint;
            }

            // Detect columns and populate chart controls
            populateChartControls(rows);

            // Check if data is suitable for charting
            const hasNumericData = detectNumericColumns(rows).length > 0;
            if (hasNumericData) {
                viewToggles.style.display = 'flex';
                chartControls.classList.add('visible');

                // Auto-suggest chart type
                const suggestion = suggestChartType(rows);
                if (suggestion && !chartHint) {
                    chartType = suggestion;
                }
                updateChartTypeButtons();
            } else {
                viewToggles.style.display = 'none';
                chartControls.classList.remove('visible');
            }

            // Render table view
            renderTableView(rows);
            currentView = 'table';
            updateViewToggles();
        }

        function parseChartHint(sql) {
            const match = sql.match(/\/\*\s*chart\s*:\s*(\w+)\s*\*\//i);
            return match ? match[1].toLowerCase() : null;
        }

        function detectNumericColumns(rows) {
            if (!rows || rows.length === 0) return [];
            const firstRow = rows[0];
            return Object.keys(firstRow).filter(col => {
                const val = firstRow[col];
                return val !== null && val !== '' && !isNaN(parseFloat(val));
            });
        }

        function detectDateColumns(rows) {
            if (!rows || rows.length === 0) return [];
            const firstRow = rows[0];
            return Object.keys(firstRow).filter(col => {
                const val = firstRow[col];
                return val !== null && !isNaN(Date.parse(val));
            });
        }

        function suggestChartType(rows) {
            const numericCols = detectNumericColumns(rows);
            const dateCols = detectDateColumns(rows);
            const colCount = Object.keys(rows[0]).length;
            const rowCount = rows.length;

            // If has date column and numeric column, suggest line chart
            if (dateCols.length > 0 && numericCols.length > 0) {
                return 'line';
            }

            // If only one numeric column, suggest histogram
            if (numericCols.length === 1 && colCount === 1) {
                return 'histogram';
            }

            // If has categorical column and numeric column, suggest bar chart
            if (numericCols.length > 0 && colCount > 1) {
                return 'bar';
            }

            // If has two numeric columns, suggest scatter
            if (numericCols.length >= 2) {
                return 'scatter';
            }

            // Default to bar
            return 'bar';
        }

        function populateChartControls(rows) {
            const columns = Object.keys(rows[0]);
            const numericCols = detectNumericColumns(rows);

            const xAxisSelect = document.getElementById('xAxisSelect');
            const yAxisSelect = document.getElementById('yAxisSelect');
            const groupSelect = document.getElementById('groupSelect');

            xAxisSelect.innerHTML = columns.map(col =>
                `<option value="${col}">${col}</option>`
            ).join('');

            yAxisSelect.innerHTML = numericCols.map(col =>
                `<option value="${col}">${col}</option>`
            ).join('');

            // Auto-select appropriate columns
            const dateCols = detectDateColumns(rows);
            if (dateCols.length > 0) {
                xAxisSelect.value = dateCols[0];
            } else if (columns.length > numericCols.length) {
                // Select first non-numeric column for x-axis
                const nonNumeric = columns.find(c => !numericCols.includes(c));
                if (nonNumeric) xAxisSelect.value = nonNumeric;
            }

            if (numericCols.length > 0) {
                yAxisSelect.value = numericCols[0];
            }

            groupSelect.innerHTML = '<option value="">None</option>' +
                columns.map(col => `<option value="${col}">${col}</option>`).join('');
        }

        function setChartType(type) {
            chartType = type;
            updateChartTypeButtons();
            switchView('chart');
            updateChart();
        }

        function updateChartTypeButtons() {
            document.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === chartType);
            });
        }

        function switchView(view) {
            currentView = view;
            updateViewToggles();

            const chartContainer = document.getElementById('chartContainer');
            const resultsContent = document.getElementById('resultsContent');

            if (view === 'chart') {
                chartContainer.classList.add('visible');
                resultsContent.style.display = 'none';
                updateChart();
            } else {
                chartContainer.classList.remove('visible');
                resultsContent.style.display = 'block';
            }
        }

        function updateViewToggles() {
            document.querySelectorAll('.view-toggle').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === currentView);
            });
        }

        function updateChart() {
            if (!chartData || !chartRenderer) return;

            const xAxis = document.getElementById('xAxisSelect').value;
            const yAxis = document.getElementById('yAxisSelect').value;
            const groupBy = document.getElementById('groupSelect').value;

            if (!xAxis || !yAxis) return;

            const processedData = {
                rows: chartData.rows,
                xAxis,
                yAxis,
                groupBy: groupBy || null
            };

            chartRenderer.setData(processedData, chartType);
            chartRenderer.resize();
        }

        function exportChart() {
            const canvas = document.getElementById('chartCanvas');
            const link = document.createElement('a');
            link.download = `chart-${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function renderTableView(rows) {
            const resultsContent = document.getElementById('resultsContent');

            if (!Array.isArray(rows) || rows.length === 0) {
                resultsContent.innerHTML = '<div class="empty-state">No results</div>';
                return;
            }

            const columns = Object.keys(rows[0]);
            const table = document.createElement('table');
            table.innerHTML = `
                <thead>
                    <tr>${columns.map(col => `<th>${col}</th>`).join('')}</tr>
                </thead>
                <tbody>
                    ${rows.map(row => `
                        <tr>${columns.map(col => `<td>${row[col] === null ? 'NULL' : row[col]}</td>`).join('')}</tr>
                    `).join('')}
                </tbody>
            `;

            resultsContent.innerHTML = '';
            resultsContent.appendChild(table);
        }

        function showError(message) {
            const resultsPanel = document.getElementById('resultsPanel');
            const resultsContent = document.getElementById('resultsContent');

            resultsPanel.style.display = 'block';
            resultsContent.innerHTML = `<div class="error">${message}</div>`;
        }

        function showSuccess(message) {
            const resultsPanel = document.getElementById('resultsPanel');
            const resultsContent = document.getElementById('resultsContent');

            resultsPanel.style.display = 'block';
            resultsContent.innerHTML = `<div class="success">${message}</div>`;
        }

        function updateStatus(isConnected) {
            const status = document.getElementById('status');
            const statusText = document.getElementById('statusText');

            if (isConnected) {
                status.className = 'status connected';
                statusText.textContent = 'Connected';
            } else {
                status.className = 'status disconnected';
                statusText.textContent = 'Disconnected';
            }
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (chartRenderer && currentView === 'chart') {
                chartRenderer.resize();
            }
        });
    </script>
</body>
</html>
